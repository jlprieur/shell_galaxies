C++***********************************************************************
C Program XYFIT1
C To compute the linear transformation between two sets of X,Y positions
C and output the 6 coefficients in a file (directly compatible with ALIGN1).
C
C SYNTAX:
C     RUNS XYFIT1 input_list1 input_list2 coeff_file option
C
C Example:
C     RUNS XYFIT1 test1.STA test2.STA test1_2.XYF 1
C
C Nota1: the input lists are simply positions x,y in an ASCII file, as
C        generated by STARFIT1, or CENTROID1
C Nota2: Possible options are
C           1 = shift only
C           2 = shift and rotation
C           3 = shift, rotation and magnification
C           4 = full 6-coefficient fit
C
C JLP
C Version 19-07-90
C--***********************************************************************
	PROGRAM XYFIT1
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*METHOD
*       obtain the input x,y position lists. assign workspace and
*       extract the x,y positions and identifiers. obtain parameters
*       controlling the fitting, then call fitlst to obtain the
*       fit and print the results.
*
*STARLINK PARAMETERS
*       ILEVEL
*               INTERACTION LEVEL: CONTROLS PRINTING OF RESULTS
*       XA, YA
*               INPUT LIST OF X, Y POSITIONS
*       XB, YB
*               SECOND INPUT LIST OF X, Y POSITIONS
*       NOSPACE/ERROR/
*               ACCESSED IF DYNAMIC STORAGE SPACE IS NOT AVAILABLE
*       FITTYPE
*               CONTROLS NUMBER OF DEGREES OF FREEDOM IN FIT
*       NSIGMA
*               NUMBER OF STANDARD DEVIATIONS AT WHICH ABERRANT POINTS
*               ARE REJECTED
*       MXREJECT
*               MAX NUMBER OF REJECTION ITERATIONS
*       TRCOEFFS
*               OUTPUT PARAMETER, GIVES 6 COEFFICIENTS DEFINING THE
*               TRANSFORMATION
*
*WRITTEN BY
*       R.F. WARREN-SMITH
*-----------------------------------------------------------------------
*
*
	PARAMETER (IDIM1=1000)
	REAL*4 XA(IDIM1),YA(IDIM1),XB(IDIM1),YB(IDIM1)
	INTEGER*4 IDIAMA(IDIM1),IDIAMB(IDIM1)
	CHARACTER NAMEA*40,NAMEB*40,NAMEOUT*40
	LOGICAL VALID(IDIM1)
	REAL*4 C(6)
 
10	FORMAT(A)
 
	CALL JLP_BEGIN
	PRINT 7
7	FORMAT(' Program XYFIT1   Version of 12-04-90',/,
     1	' To compute the linear transformation',/,
     1	' from two input lists of coordinates of the same objects')
 
*
* OBTAIN INTERACTION LEVEL  (3=talkative, 1=quiet)
*
	ilevel=3
        open(4,file='xyfit1.dat',status='new')
 
C	call getpar('ILEVEL','INTEGER',1,1.0,3.0,.true.,ilevel,rval,ierr)
 
* Input of the two lists :
 
C Read the first list XA, YA :
15	PRINT *,' NAME OF THE FIRST LIST :'
	READ(5,10) NAMEA
	OPEN(1,FILE=NAMEA,STATUS='OLD',ERR=15)
	I=0
94	IF(I.GE.IDIM1) GOTO 17
	   I=I+1
	   READ(1,*,END=17)XA(I),YA(I),IDIAMA(I)
        GOTO 94
17	NPTSA=I-1
	CLOSE(1)
	PRINT *,NPTSA,' POINTS RECEIVED'
 
C Read the second list XB, YB :
16	PRINT *,' NAME OF THE SECOND LIST :'
	READ(5,10) NAMEB
	OPEN(2,FILE=NAMEB,STATUS='OLD',ERR=16)
	I=0
95	IF(I.GE.IDIM1) GOTO 21
	   I=I+1
	   READ(2,*,END=21)XB(I),YB(I),IDIAMB(I)
        GOTO 95
21	NPTSB=I-1
	CLOSE(2)
	PRINT *,NPTSB,' POINTS RECEIVED'
 
C Exit if one of the lists is empty :
	NPTS=MIN(NPTSA,NPTSB)
	IF(NPTS.EQ.0)THEN
	 PRINT *,' EMPTY INPUT LIST'
	 STOP
	ENDIF
 
23	PRINT *,' NAME OF THE OUTPUT FILE :'
	READ(5,10) NAMEOUT
	OPEN(3,FILE=NAMEOUT,STATUS='NEW',ERR=23)
*
* OBTAIN TYPE OF FIT (IFIT), NO. OF SIGMA REJECTION THRESHOLD (GAMMA)
* AND MAX NO. OF REJECTED POINTS (MAXIT)
*
	      PRINT *,' TYPE OF FIT : 1 SHIFT ONLY, 2 SHIFT AND ROTATION'
	      PRINT *,' 3 SHIFT, ROTATION, MAGNI.  4 FULL 6 COEFFICIENTS ?'
	      READ(5,*) IFIT
	      PRINT *,'      FITTYPE =',IFIT
	      gamma=1.0e10
CC	      PRINT *,' NO. OF SIGMA REJECTION'
C	      call getpar('NSIGMA','REAL',1,0.0,1.0e10,.true.,ival,gamma
C     1	,ierr)
CC	      READ(5,*) GAMMA
C	      PRINT *,'      NSIGMA =',GAMMA
	      maxit=NPTS
CC	      PRINT *,' MAX NO. OF REJECTED POINTS'
C	      call getpar('MXREJECT','INTEGER',1,0.0,1.0e7,.true.,maxit
C     1	,rval,ierr)
CC	      READ(5,*) MAXIT
C	      PRINT *,'      MAXREJECT =',MAXIT
 
*
* IF NO MATCHES ARE FOUND BETWEEN THE TWO SETS OF POSITIONS, GIVE
* MESSAGE AND ABORT
*
C Tolerance for the positions : 1.0 pixel
	TOLER=1.
	CALL MATCH_LIST(XA,YA,IDIAMA,NPTSA,XB,YB,IDIAMB,
     1	NPTSB,TOLER,NMATCH,IERRM)
 
	      if(ierrm.ne.0.or.nmatch.lt.2) then
	 	 PRINT *,' THE TWO LISTS DO NOT MATCH'
	         go to 99
	      endif
 
*
* CALL FITLST TO PERFORM THE FITTING AND DISPLAY THE RESULTS
*
	      call fitlst(XA,YA,XB,YB,NMATCH
     1	,maxit,gamma,ifit,ilevel,C,VALID)
 
*
* WRITE TRANSFORMATION COEFFICIENTS TO THE OUTPUT FILE
	      WRITE(3,*)(C(K),K=1,6)
 
*
* FREE DATA AREAS
*
99	CLOSE(3)
	CLOSE(4)
	CALL JLP_END
	STOP
	END
 
C@*********************************************************************
C FITLST
C@*********************************************************************
	SUBROUTINE FITLST(XA,YA,XB,YB,NPTS,maxit
     1	,gamma,ifit,ilevel,c,valid)
 
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*       TO CONTROL THE FITTING OF A LINEAR TRANSFORMATION BETWEEN
*       TWO SETS OF X,Y POSITIONS AND TO DISPLAY THE RESULTS
*
*METHOD
*       CALL XYFITR TO PERFORM
*       THE FITTING, THEN DISPLAY A TABLE OF RESULTS.
*
*ARGUMENTS
*       XA, YA
*               INPUT LIST OF X, Y POSITIONS
*       XB, YB
*               SECOND INPUT LIST OF X, Y POSITIONS
*       MAXIT (IN)
*       INTEGER
*               THE MAXIMUM NUMBER OF REJECTION ITERATIONS TO BE
*               PERFORMED BY THE FITTING ROUTINE XYFITR
*       GAMMA (IN)
*       REAL
*               THE NUMBER OF STANDARD DEVIATIONS AT WHICH ABERRANT
*               POINTS ARE REJECTED IN XYFITR
*       IFIT (IN)
*       INTEGER
*               AN INTEGER DEFINING THE TYPE OF LINEAR TRANSFORMATION
*               CALCULATED BY XYFITR
*       ILEVEL (IN)
*       INTEGER
*               INTERACTION LEVEL, CONTROLLING THE PRINTING OF RESULTS
*       C (OUT)
*       REAL(6)
*               RETURNS THE 6 TRANSFORMATION COEFFICIENTS
*       XB,YB (WORKSPACE)
*       REAL(NPTS)
*               STORAGE FOR X,Y POSITIONS
*       VALID (WORKSPACE)
*       LOGICAL(*)
*               USED TO HOLD FLAGS INDICATING WHICH POINTS WERE REJECTED
*               DURING FITTING. SHOULD BE AT LEAST NPTS
*               ELEMENTS LONG
*
*CALLS
*       THIS PACKAGE:
*               XYFITR
*
*NOTES
*       USES BYTE ARRAYS
*
*WRITTEN BY
*       R.F. WARREN-SMITH
*-----------------------------------------------------------------------
      real xa(NPTS),ya(NPTS),xb(NPTS),yb(NPTS),c(6)
      logical valid(*)
      character prbuf*80,fitmsg(4)*80
 
*
* SET UP INFORMATION MESSAGES TO INDICATE THE FIT USED
*
      data fitmsg(1)/'   TRANSFORMATION IS A SHIFT OF ORIGIN ONLY'/
     : ,fitmsg(2)/'   TRANSFORMATION IS A SHIFT AND ROTATION'/,
     : fitmsg(3)/
     : '   TRANSFORMATION IS A SHIFT,ROTATION AND MAGNIFICATION'/,
     : fitmsg(4)/'   TRANSFORMATION IS A FULL 6 PARAMETER FIT'/
 
 
*
* SET ALL MATCHED POSITIONS AS VALID, THEN CALL XYFITR TO PERFORM
* THE FITTING
 
      do 1 i=1,npts
         valid(i)=.true.
1     continue
 
      call xyfitr(xa,ya,xb,yb,valid,npts,maxit,gamma,ifit,c,ierr)
 
*
* PRINT NUMBER OF MATCHED POSITIONS
*
 
      if(ilevel.ge.2) then
         write(6,10)npts
10       format(3x,i8,' POSITION(S) MATCHED BETWEEN INPUT LISTS')
      endif
 
 
*
* IF TABLE OF RESULTS IS NEEDED, PRINT HEADINGS
*
 
      if(ilevel.ge.3) then
         write(6,11)
         write(4,11)
11       format(3x,'TRANSFORMED A POSITION',12x,'B POSITION',/,
     1	3x,'----------------------',12x,'----------',/,
     1	2x,2(' X COORD.      Y COORD.     '),3x,'ALIGNMENT ERROR',/,
     1	2x,2(' --------      --------     '),3x,'---------------')
      endif
 
*
* CALCULATE RMS ERROR AND COUNT NUMBER OF POSITIONS REJECTED
*
 
      if(ilevel.ge.2) then
         nrej=0
         sigma=0.0
 
         do 66 i=1,npts
 
*
* CALCULATE TRANSFORMED 'A' POSITIONS AND ERROR
*
            xd=c(1)+c(2)*xa(i)+c(3)*ya(i)
            yd=c(4)+c(5)*xa(i)+c(6)*ya(i)
            errsq=(xd-xb(i))**2+(yd-yb(i))**2
            err=sqrt(errsq)
 
            if(valid(i)) then
 
*
* INCREASE SUM OF ERRORS AND PRINT RESULT IF REQUIRED
*
               sigma=sigma+errsq
 
               if(ilevel.ge.3) write(prbuf,15)xd,yd,xb(i),yb(i),err,
     :         'OK'
 
            else
 
*
* COUNT ONE REJECTED POINT AND PRINT RESULT IF REQUIRED
*
               nrej=nrej+1
 
               if(ilevel.ge.3) write(prbuf,15)xd,yd,xb(i),yb(i),err,
     :         'REJ'
            endif
 
15          format(1x,4(1x,ss,g13.6),4x,ss,g12.4,2x,a3)
 
66       continue
 
 
*
* CALCULATE RMS ERROR AND PRINT NO. OF REJECTED POINTS AND RMS ERROR
*
 
         if(nrej.lt.npts) then
            sigma=sqrt(sigma/(npts-nrej))
          else
            sigma=0.0
         endif
 
         write(6,16) nrej,sigma
         write(4,16) nrej,sigma
16       format(3x,i8,' POSITION(S) REJECTED',/,
     1	3x,'RMS ALIGNMENT ERROR=',ss,g11.4)
 
*
* PRINT MESSAGE SHOWING TYPE OF FIT USED
*
	 write(6,'(A)') fitmsg(ifit)
         write(4,'(A)') fitmsg(ifit)
 
*
* FINALLY PRINT THE TRANSFORMATION COEFFICIENTS
*
         write(6,18)
         write(4,18)
18       format(3x,'TRANSFORMATION COEFFICIENTS:')
 
         do 44 j=1,4,3
* JLP99:
*           write(6,19)((l,c(l)),l=j,j+2)
*           write(4,19)((l,c(l)),l=j,j+2)
            write(6,19)j,c(j),j+1,c(j+1),j+2,c(j+2)
            write(4,19)j,c(j),j+1,c(j+1),j+2,c(j+2)
19          format(10x,3('C(',i1,')=',ss,g13.6,2x))
44       continue
 
      endif
 
99    return
 
      end
 
C@**********************************************************************
C XYFITR
C@**********************************************************************
 
      subroutine xyfitr(xa,ya,xb,yb,ok,n,maxit,gamma,ifit,c,ierr)
 
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*       TO FIND A LEAST-SQUARES LINEAR TRANSFORMATION BETWEEN TWO SETS
*       OF X,Y POSITIONS, REJECTING ERRONEOUS DATA.
*
*METHOD
*       CALL LINTRN TO OBTAIN A LEAST-SQUARES FIT. CALCULATE THE RMS
*       MIS-ALIGNMENT AND THE MOST MIS-ALIGNED DATA POINT. REJECT THE
*       WORST POINT IF IT EXCEEDS A THRESHOLD BASED ON THE RMS ERROR.
*       REPEAT FOR A PRESET NUMBER OF ITERATIONS, OR UNTIL NO FURTHER
*       POINTS ARE REJECTED
*
*ARGUMENTS
*       XA,YA (IN)
*       REAL(N)
*               THE FIRST SET OF POSITIONS TO BE TRANSFORMED
*       XB,YB (IN)
*       REAL(N)
*               THE SECOND SET OF REFERENCE POSITIONS
*       OK (IN/OUT)
*       LOGICAL(N)
*               FLAGS TO INDICATE WHICH DATA POINTS HAVE NOT BEEN
*               REJECTED
*       N (IN)
*       INTEGER
*               NUMBER OF DATA POINTS
*       MAXIT (IN)
*       INTEGER
*               MAX. NUMBER OF REJECTION ITERATIONS
*       GAMMA (IN)
*       REAL
*               NUMBER OF STANDARD DEVIATIONS AT WHICH ABERRANT POINTS
*               ARE REJECTED
*       IFIT (IN/OUT)
*       INTEGER
*               FLAG WHICH INDICATES THE TYPE OF LINEAR TRANSFORMATION
*               USED... SERVES THE SAME PURPOSE AS IN LINTRN
*       C (OUT)
*       REAL(6)
*               THE COEFFICIENTS DEFINING THE TRANSFORMATION
*       IERR (OUT)
*       INTEGER
*               ERROR FLAG: ZERO FOR SUCCESS
*
*CALLS
*       THIS PACKAGE:
*               LINTRN
*
*WRITTEN BY
*       R.F. WARREN-SMITH
*-----------------------------------------------------------------------
*
*
      real xa(n),ya(n),xb(n),yb(n),c(6)
      logical ok(n),reject
 
*
* INITIALLISE ITERATION COUNT AND LOOP WHILE POINTS WERE REJECTED LAST
* ITERATION
*
      iter=0
      reject=.true.
 
63    if(reject) then
 
*
* CALL LINTRN TO FIND THE LINEAR TRANSFORMATION BETWEEN THE 2 SETS
* OF X,Y POSITIONS
*
         call lintrn(xa,ya,xb,yb,ok,n,c,ifit,ierr)
 
*
* QUIT IF ERROR, OR MAX ITERATIONS EXCEEDED
*
 
         if((ierr.eq.0).and.(iter.lt.maxit)) then
 
*
* COUNT 1 ITERATION AND INITIALLISE REJECTED POINTS FLAG
*
            iter=iter+1
            reject=.false.
 
*
* INITIALLISE COUNTERS FOR FINDING STANDARD DEVIATION AND MAXIMUM
* MIS-ALIGNMENT
*
            varsum=0.0
            ngood=0
            errmax=-1.0
 
*
* SCAN ALL POINTS NOT REJECTED SO FAR
*
 
            do 2 i=1,n
 
               if(ok(i)) then
 
*
* CALCULATE THE MIS-ALIGNMENT
*
                  xd=c(1)+c(2)*xa(i)+c(3)*ya(i)
                  yd=c(4)+c(5)*xa(i)+c(6)*ya(i)
                  errsq=(xb(i)-xd)**2+(yb(i)-yd)**2
                  varsum=varsum+errsq
                  ngood=ngood+1
 
*
* FIND THE MAXIMUM MIS-ALIGNMENT
*
 
                  if(errsq.gt.errmax) then
                     errmax=errsq
                     imax=i
                  endif
 
               endif
 
2           continue
 
 
*
* FIND THE RMS MIS-ALIGNMENT AND REJECT THE WORST POINT IF IT IS MORE
* THAN GAMMA STD. DEVS. OUT
*
 
            if(ngood.gt.0) then
               var=varsum/ngood
 
               if((var.gt.0.0).and.(errmax.gt.var*(gamma**2))) then
                  ok(imax)=.false.
                  reject=.true.
               endif
 
            endif
 
            go to 63
 
         endif
 
      endif
 
      return
 
      end
 
 
C***************************************************************************
C Subroutine MATCH_LIST to match the two input lists of positions
C JLP 18/08/87
C
C At present work only for shifts (not for rotations nor expansions)
C
C XA,YA (IN/OUT) : List A of positions
C
C XB,YB (IN/OUT) : List B of positions
C
C
C CXA, CXB : Arrays XA and XB sorted according to the diameter of the objects
C CYA, CYB : Arrays YA and YB sorted according to the diameter of the objects
C DISTA : Relative distances of list A to a given object of list A
C DISTB : Relative distances of list B to a given object of list B
C***************************************************************************
 
 
	SUBROUTINE MATCH_LIST(XA,YA,IDIAMA,NPTSA,XB,YB,IDIAMB,
     1	NPTSB,TOLER,NMATCH,ISTAT)
	PARAMETER (IDIM1=1000)
	REAL*4 XA(NPTSA),YA(NPTSA),XB(NPTSB),YB(NPTSB)
	REAL*4 CXA(IDIM1),CYA(IDIM1),CXB(IDIM1),CYB(IDIM1)
	REAL*4 DISTA(10),DISTB(10)
	INTEGER*4 IDIAMA(NPTSA),IDIAMB(NPTSB)
	INTEGER*4 INDEXA(IDIM1),INDEXB(IDIM1),KMATCH(10,10)
 
	ISTAT=0
	
C*******************
C First looking for the 10 largest objects
	
	NPTS=MIN(NPTSA,NPTSB)
	IF(NPTS.GT.1)THEN
C Sorts the array IDIAMA in descending order with INDEXA(I)=initial index
	   CALL SORT_INT4(IDIAMA,INDEXA,NPTSA,'D')
C	   NWORK=IDIM1
C NEW NAG: CALL M01DBF(IDIAMA,1,NPTSA,'D',INDEXA,IFAIL)
	   DO I=1,NPTSA
	     CXA(I)=XA(INDEXA(I))
	     CYA(I)=YA(INDEXA(I))
	   END DO
 
C Sorts the array IDIAMB in descending order with INDEXB(I)=initial index
C	   NWORK=IDIM1
C NEW NAG : CALL M01DBF(IDIAMB,1,NPTSB,'D',INDEXB,IFAIL)
	   CALL SORT_INT4(IDIAMB,INDEXB,NPTSB,'D')
	   DO I=1,NPTSB
	     CXB(I)=XB(INDEXB(I))
	     CYB(I)=YB(INDEXB(I))
	   END DO
	ELSE
	   PRINT *,' TOO FEW POINTS TO FIT ANYTHING !!!'
	   ISTAT=1
	   RETURN
	ENDIF
 
	NPTS=MIN(10,NPTS)
 
C************************
C Compute a cross-correlation matrix of the two lists :
C Loop on all the objects of list A to look for the best agreement with list B
	DO IA=1,NPTS
 
C Computing the distances relative to the object IA :
	  DO KA=1,NPTS
	   DISTA(KA)=SQRT((CXA(KA)-CXA(IA))**2
     1	+ (CYA(KA)-CYA(IA))**2)
	  END DO
 
C For each position of IB, looking for the best agreement in list B :
	    DO IB=1,NPTS
 
C Computing the distances relative to the object IB :
	       DO KB=1,NPTS
	         DISTB(KB)=SQRT((CXB(KB)-CXB(IB))**2
     1	 + (CYB(KB)-CYB(IB))**2)
	       END DO
 
C Looking for similar distances with array A :
	     KMATCH(IB,IA)=0
	      DO KA=1,NPTS
	       DO KB=1,NPTS
	        WORK=ABS(DISTB(KB)-DISTA(KA))
	        IF(WORK.LT.TOLER)KMATCH(IB,IA)=KMATCH(IB,IA)+1
	       END DO
	      END DO
	
C Go to another position in list B
	  END DO
 
C Go to another position in list A
	END DO
 
 
C *****************
C Looking for the maximum of the correlation array KMATCH :
	IAMAX=1
	IBMAX=1
	KMAX=0
	DO IA=1,NPTS
	  DO IB=1,NPTS
	    IF(KMATCH(IB,IA).GT.KMAX)THEN
	     IAMAX=IA
	     IBMAX=IB
	     KMAX=KMATCH(IB,IA)
	    ENDIF
	  END DO
	END DO
	
C********************
C Return if no correlation found between the two lists :
	IF(KMAX.EQ.0)THEN
	 PRINT *,' NO CORRELATION FOUND BETWEEN THE TWO LISTS'
	 ISTAT=1
	 RETURN
	ENDIF
 
C********************
C If correlation found
C get a first approximation of DELTAX and DELTAY :
	DELTAX=CXA(IAMAX)-CXB(IBMAX)
	DELTAY=CYA(IAMAX)-CYB(IBMAX)
 
C********************
C and sort the two lists in the same order :
	NMATCH=0
	 DO IA=1,NPTSA
	   DO IB=1,NPTSB
	    WORK1=ABS(CXA(IA)-CXB(IB)-DELTAX)
	    WORK2=ABS(CYA(IA)-CYB(IB)-DELTAY)
	    WORK3=AMAX1(WORK1,WORK2)
	     IF(WORK3.LT.TOLER)THEN
	      NMATCH=NMATCH+1
	      XA(NMATCH)=CXA(IA)
	      XB(NMATCH)=CXB(IB)
	      YA(NMATCH)=CYA(IA)
	      YB(NMATCH)=CYB(IB)
	      GO TO 2
	     ENDIF
	   END DO
2	 END DO
	IF(NMATCH.EQ.0)ISTAT=2
 
	PRINT *,' NMATCH=',NMATCH
 
	RETURN
	END
C**********************************************************************
      subroutine lintrn(xa,ya,xb,yb,ok,n,c,ifit,ierr)
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*       TO OBTAIN A LINEAR TRANSFORMATION BETWEEN 2 SETS OF X,Y
*       POSITIONS WITH LEAST SQUARED ERROR.
*
*METHOD
*       SET UP THE NORMAL EQUATIONS CORRESPONDING TO THE TYPE OF FIT
*       REQUIRED. SOLVE NORMAL EQUATIONS TO GIVE THE TRANSFORMATION.
*       IF SUCCESSFUL, EXIT. OTHERWISE REDUCE THE NUMBER OF DEGREES
*       OF FREEDOM IN THE FIT AND REPEAT.
*
*ARGUMENTS
*       XA,YA (IN)
*       REAL(N)
*               THE FIRST SET OF X,Y POSITIONS WHICH ARE TO BE
*               TRANSFORMED
*       XB,YB (IN)
*       REAL(N)
*               THE SECOND (REFERENCE) SET OF POSITIONS
*       OK (IN)
*       LOGICAL(N)
*               A SET OF LOGICAL FLAGS INDICATING WHICH POSITIONS ARE
*               TO BE USED
*       N (IN)
*       INTEGER
*               THE SIZE OF ARRAYS XA,YA,XB,YB,OK
*       C (OUT)
*       REAL(6)
*               THE SIX COEFFICIENTS DEFINING THE TRANSFORMATION
*       IFIT (IN/OUT)
*       INTEGER
*               THE TYPE OF FIT REQUIRED:
*               1:SHIFT OF ORIGIN
*               2:SHIFT AND ROTATION
*               3:SHIFT, ROTATION AND MAGNIFICATION
*               4:FULL 6 PARAMETER TRANSFORMATION
*               IFIT MAY BE REDUCED ON OUTPUT IF THE SPECIFIED FIT
*               WAS NOT OBTAINED
*       IERR (OUT)
*       INTEGER
*               ERROR FLAG: ZERO FOR SUCCESS
*
*CALLS
*       NAG LIBRARY:
*               F04AEF
*
*WRITTEN BY
*       R.F. WARREN-SMITH
*-----------------------------------------------------------------------
*
*
      real xa(n),ya(n),xb(n),yb(n),c(6)
      double precision a(4,4),b(4,2),ans(4,2),wkspce(4),aa(4,4),bb(4,2)
      logical ok(n)
 
*
* CHECK VALIDITY OF ARGUMENTS
*
      ierr=0
 
      if(n.lt.1) then
         ierr=1
 
      else
 
*
* IS AT LEAST 1 POSITION VALID?
*
         sw=0.0
 
         do 10 i=1,n
 
            if(ok(i)) sw=sw+1.0
10       continue
 
 
         if(sw.le.0.0) then
            ierr=2
 
         else
 
*
* OK...SET TYPE OF FIT REQUIRED BETWEEN 1 AND 4
*
            ifit=min(max(1,ifit),4)
 
*
* CHECK THAT THE FIT DOES NOT HAVE TOO MANY DEGREES OF FREEDOM FOR
* THE NUMBER OF DATA POINTS AVAILABLE
*
            npts=nint(sw)
 
            if(npts.le.2) ifit=min(ifit,3)
 
            if(npts.le.1) ifit=1
 
*
* INITIALLISE SUMS FOR NORMAL EQUATIONS
*
            swx=0.0
            swy=0.0
            swxy=0.0
            swx2=0.0
            swy2=0.0
            swxd=0.0
            swyd=0.0
            swxxd=0.0
            swyyd=0.0
            swxyd=0.0
            swyxd=0.0
 
*
* FORM SUMS, SETTING WEIGHT TO ZERO FOR INVALID POSITIONS
*
 
            do 20 i=1,n
 
               if(ok(i)) then
                  w=1.0
 
               else
                  w=0.0
               endif
 
               wx=w*xa(i)
               wy=w*ya(i)
               swx=swx+wx
               swy=swy+wy
               swxd=swxd+w*xb(i)
               swyd=swyd+w*yb(i)
 
*
* IF FIT ONLY REQUIRES A SHIFT OF ORIGIN, FURTHER SUMS ARE NOT
* REQUIRED
*
 
               if(ifit.ne.1) then
                  swxy=swxy+wx*ya(i)
                  swx2=swx2+wx*xa(i)
                  swy2=swy2+wy*ya(i)
                  swxxd=swxxd+wx*xb(i)
                  swxyd=swxyd+wx*yb(i)
                  swyxd=swyxd+wy*xb(i)
                  swyyd=swyyd+wy*yb(i)
               endif
 
20          continue
 
 
*
* ITERATE UP TO 4 TIMES, REDUCING IFIT BY 1 EACH TIME
*
            ifit=ifit+1
 
            do 60 itry=1,4
               ifit=ifit-1
 
*
* SHIFT OF ORIGIN ONLY: EQUATIONS SIMPLY SOLVED
* --------------------
*
 
               if(ifit.eq.1) then
                  c(1)=(swxd-swx)/sw
                  c(2)=1.0
                  c(3)=0.0
                  c(4)=(swyd-swy)/sw
                  c(5)=0.0
                  c(6)=1.0
                  ifail=0
 
*
* SHIFT OF ORIGIN AND ROTATION
* ----------------------------
 
               else if(ifit.eq.2) then
 
*
* CALCULATE THE CENTROIDS OF EACH SET OF POSITIONS
*
                  xd0=swxd/sw
                  yd0=swyd/sw
                  x0=swx/sw
                  y0=swy/sw
 
*
* INITIALLISE STORAGE FOR NEW SUMS
*
                  swyxd0=0.0
                  swxyd0=0.0
                  swxxd0=0.0
                  swyyd0=0.0
 
*
* FORM NEW SUMS, USING THE DEVIATIONS FROM THE CENTROIDS
*
 
                  do 146 i=1,n
 
                     if(ok(i)) then
                        swyxd0=swyxd0+(ya(i)-y0)*(xb(i)-xd0)
                        swxyd0=swxyd0+(xa(i)-x0)*(yb(i)-yd0)
                        swxxd0=swxxd0+(xa(i)-x0)*(xb(i)-xd0)
                        swyyd0=swyyd0+(ya(i)-y0)*(yb(i)-yd0)
                     endif
 
146               continue
 
 
*
* IF THE ROTATION ANGLE IS NOT DEFINED, IFAIL=1
*
                  top=swyxd0-swxyd0
                  bot=swyyd0+swxxd0
 
                  if(top.eq.0.0.and.bot.eq.0.0) then
                     ifail=1
 
                  else
 
*
* OTHERWISE CALCULATE THE ROTATION ANGLE ABOUT THE CENTROIDS
* AND ASSIGN THE RESULTS TO THE TRANSFORM COEFFICIENTS
*
                     theta=atan2(top,bot)
                     c(1)=xd0-(x0*cos(theta)+y0*sin(theta))
                     c(2)=cos(theta)
                     c(3)=sin(theta)
                     c(4)=yd0-(-x0*sin(theta)+y0*cos(theta))
                     c(5)=-sin(theta)
                     c(6)=cos(theta)
                     ifail=0
                  endif
 
 
*
* SHIFT, ROTATION AND MAGNIFICATION: SET UP NORMAL EQUATIONS
* ---------------------------------
*
 
               else if(ifit.eq.3) then
                  a(1,1)=sw
                  a(1,2)=swx
                  a(1,3)=swy
                  a(1,4)=0.0d0
                  a(2,1)=swx
                  a(2,2)=swx2+swy2
                  a(2,3)=0.0d0
                  a(2,4)=swy
                  a(3,1)=swy
                  a(3,2)=0.0d0
                  a(3,3)=swx2+swy2
                  a(3,4)=-swx
                  a(4,1)=0.0d0
                  a(4,2)=swy
                  a(4,3)=-swx
                  a(4,4)=sw
                  b(1,1)=swxd
                  b(2,1)=swxxd+swyyd
                  b(3,1)=swyxd-swxyd
                  b(4,1)=swyd
 
*
* CALL NAG ROUTINE F04AEF TO SOLVE THE LINEAR NORMAL EQUATIONS
*
                  ifail=1
                  call f04aef(a,4,b,4,4,1,ans,4,wkspce,aa,4,bb,4,ifail)
 
*
* IF SUCCESSFUL, ASSIGN RESULT TO THE TRANSFORMATION COEFFICIENTS
*
 
                  if(ifail.eq.0) then
                     c(1)=ans(1,1)
                     c(2)=ans(2,1)
                     c(3)=ans(3,1)
                     c(4)=ans(4,1)
                     c(5)=-ans(3,1)
                     c(6)=ans(2,1)
                  endif
 
 
*
* FULL FIT REQUIRED: SET UP NORMAL EQUATIONS
* -----------------
*
 
               else if(ifit.eq.4) then
                  a(1,1)=sw
                  a(1,2)=swx
                  a(1,3)=swy
                  a(2,1)=swx
                  a(2,2)=swx2
                  a(2,3)=swxy
                  a(3,1)=swy
                  a(3,2)=swxy
                  a(3,3)=swy2
                  b(1,1)=swxd
                  b(2,1)=swxxd
                  b(3,1)=swyxd
                  b(1,2)=swyd
                  b(2,2)=swxyd
                  b(3,2)=swyyd
 
*
* CALL NAG ROUTINE F04AEF TO SOLVE LINEAR NORMAL EQUATIONS
*
                  ifail=1
                  call f04aef(a,4,b,4,3,2,ans,4,wkspce,aa,4,bb,4,ifail)
 
*
* IF SUCCESSFUL, ASSIGN RESULTS TO TRANSFORMATION COEFFICIENTS
*
 
                  if(ifail.eq.0) then
                     c(1)=ans(1,1)
                     c(2)=ans(2,1)
                     c(3)=ans(3,1)
                     c(4)=ans(1,2)
                     c(5)=ans(2,2)
                     c(6)=ans(3,2)
                  endif
 
               endif
 
 
*
* IF A FIT WAS SUCCESSFULLY OBTAINED THIS TIME, EXIT FROM ITERATION
* LOOP. OTHERWISE TRY AGAIN WITH IFIT REDUCED BY 1
*
 
               if(ifail.eq.0) go to 70
60          continue
 
70          continue
         endif
 
      endif
 
      return
 
      end
C**************************************************************
      include 'jlpsub:sort_set.for'
